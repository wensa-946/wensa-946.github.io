import{_ as i,c as a,a2 as n,o as l}from"./chunks/framework.BQmytedh.js";const c=JSON.parse('{"title":"性能优化","description":"CSS 性能优化","frontmatter":{"title":"性能优化","description":"CSS 性能优化","kewords":["css","性能优化"]},"headers":[],"relativePath":"HtmlCss合集/CSS合集/性能优化.md","filePath":"HtmlCss合集/CSS合集/性能优化.md","lastUpdated":1732683187000}'),e={name:"HtmlCss合集/CSS合集/性能优化.md"};function t(p,s,r,h,k,d){return l(),a("div",null,s[0]||(s[0]=[n(`<h3 id="为什么有时候用-translate-来改变位置而不是定位" tabindex="-1">为什么有时候用 translate 来改变位置而不是定位 ? <a class="header-anchor" href="#为什么有时候用-translate-来改变位置而不是定位" aria-label="Permalink to &quot;为什么有时候用 translate 来改变位置而不是定位 ?&quot;">​</a></h3><p>在前端开发中，我们有时候会选择使用 <code>translate</code> 来改变元素的位置，而不是使用传统的定位方式（如 <code>top</code>, <code>left</code>, <code>right</code>, <code>bottom</code>），主要是因为性能方面的考虑。</p><p>具体来说，<code>translate</code> 是通过 CSS <code>transforms</code> 实现的，它操作的是元素的渲染层，而不是布局层。这样一来，浏览器就不会因为位置的改变而重新计算布局（reflow），从而提高渲染性能。</p><details class="details custom-block"><summary>补充</summary><ul><li><strong>Reflow 与 Repaint</strong><ul><li>Reflow（重排）：是指浏览器在 DOM 发生变化时重新计算元素的位置和几何形状。当使用定位属性（如 <code>top</code>, <code>left</code>）改变元素位置时，就会触发 Reflow，这在页面复杂时会非常消耗性能。</li><li>Repaint（重绘）：是指元素的外观发生变化（如背景颜色、边框等）时，需要重新绘制这些元素，但不涉及重新计算布局。Repaint 的开销相对较小。</li></ul></li><li><strong>Transform - Translate</strong>: <code>translate</code> 是 CSS <code>Transform</code> 属性的一部分，通过矩阵变换（matrix transformations）来操作元素的视觉位置。这个过程是在合成层（compositing layer）完成的，不会影响文档的布局结构，所以不会触发 Reflow，只会造成 Repaint。</li><li><strong>硬件加速</strong>: 使用 <code>translate</code> 通常能够借助 GPU 加速，而传统的定位方式则主要依赖于 CPU。在渲染大量图形和动画时，GPU 的效率是显著优于 CPU 的，能带来更流畅的视觉效果。</li><li><strong>性能优化的常见实践</strong><ul><li>在涉及到动画和频繁调整位置的场景下，应该优先考虑使用 <code>transform: translate</code>，而不是 <code>top</code> 或 <code>left</code>。</li><li>合理利用 <code>will-change</code> 属性，告知浏览器即将发生的一些变化（如 <code>transform</code> 或 <code>opacity</code>），预先做一些优化处理，提高动画的流畅度。</li></ul></li><li><strong>实际应用中的权衡</strong>: 尽管 <code>translate</code> 在性能上具有优势，但也不是所有情况下都适用。例如，对于特定布局需求或固定定位（fixed positioning）的情景，传统的定位方式依然不可或缺。因此，我们需要根据具体需求和性能考量做出合理选择。</li></ul></details><h3 id="说说你对-css-sprites-的理解" tabindex="-1">说说你对 CSS Sprites 的理解 ? <a class="header-anchor" href="#说说你对-css-sprites-的理解" aria-label="Permalink to &quot;说说你对 CSS Sprites 的理解 ?&quot;">​</a></h3><details class="details custom-block"><summary>含义</summary><p>CSS Sprites（雪碧图）是一种网页性能优化的技术。其核心思想是将多个小图标合并到一张大图中，通过 CSS 来控制显示具体的图标部分。这种技术能够有效减少 HTTP 请求次数，从而提高页面加载速度。</p></details><details class="details custom-block"><summary>作用</summary><ul><li>减少 HTTP 请求：每次加载一个图像都会发起一次 HTTP 请求，合并图像后只需一次请求，就能获取所需的所有图像。</li><li>节省带宽：由于多个图像合并为一个文件，服务器和客户端之间传输的数据包数更少，减少了服务器的开销和客户端解析图像的时间。</li><li>改善用户体验：页面加载速度更快，可提升用户体验，尤其是在网络条件不佳的情况下。</li></ul></details><details class="details custom-block"><summary>补充</summary><ul><li>实现方式 <ul><li>我们需要一张包含多个小图标的大图，以及对应的 CSS 样式。</li><li>每个图标通过调整 <code>background-position</code> 属性来显示其在大图中的正确位置。</li></ul></li></ul><div class="language-css vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.icon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  background-image</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">url</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;sprites.png&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  background-repeat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">no-repeat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.icon-home</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  background-position</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.icon-user</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  height</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">32</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  background-position</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">-32</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><ul><li><strong>工具和自动化</strong>: 手动制作和调整雪碧图可能会非常繁琐。而这点我们可以借助工具来生成雪碧图和自动生成相应的 CSS 代码。例如 Grunt、Gulp、Webpack 都有相应的插件，能够帮助实现这一过程。</li><li><strong>适用场景</strong>: 合适使用 CSS Sprites 的场景通常是较多的小图标被频繁使用的地方，例如导航栏、按钮等。但是对于大图或者背景图，使用 CSS Sprites 并不合适。而且过于复杂的雪碧图可能会导致维护和更新的成本增加。</li><li><strong>常见问题</strong><ul><li>图片位置偏移：由于 <code>background-position</code> 属性的精度非常重要，稍有偏差便可能导致图像显示错误，因此在生成雪碧图时，要格外注意位置的准确性。</li><li>图像内容更新频繁：如果某些图标需要频繁更新，那么每次都要更新整个雪碧图，这会导致维护成本较高。</li></ul></li></ul></details><h3 id="css-优化和提高性能的方法有哪些" tabindex="-1">CSS 优化和提高性能的方法有哪些 ? <a class="header-anchor" href="#css-优化和提高性能的方法有哪些" aria-label="Permalink to &quot;CSS 优化和提高性能的方法有哪些 ?&quot;">​</a></h3><details class="details custom-block"><summary><strong>合并和最小化 CSS 文件</strong></summary><p>通过工具（如 Webpack、Gulp）将多个 CSS 文件合并为一个，并最小化 CSS 代码，减少文件大小和请求数。</p><ul><li>合并 CSS 文件可以减少 HTTP 请求数，因为每个请求都会带来额外的网络开销。</li><li>最小化 CSS 文件可以减少文件大小，通过删除空格、注释等无用字符，使得传输速率更快。常用的工具有 CSSNano、UglifyCSS 等。</li></ul></details><details class="details custom-block"><summary><strong>使用 CSS 预处理器</strong></summary><p>利用 Sass、Less 这些预处理器，可以编写更简洁高效的 CSS 代码，并支持变量、嵌套等特性。</p><ul><li>预处理器能够帮助我们编写更具逻辑性和可维护性的代码，比如利用变量存储重复的值，使用嵌套减少选择器层级等。</li><li>预处理器还支持混入和函数。</li></ul></details><details class="details custom-block"><summary><strong>减少使用高级选择器</strong></summary><p>避免使用复杂的选择器（如后代选择器、通配符选择器），优先使用类选择器，减少浏览器的解析时间。</p><ul><li>比如后代选择器（<code>div p</code>）和通配符选择器（<code>*</code>）会让浏览器遍历更多的 DOM 节点，从而增加渲染时间。</li><li>使用更具体的类选择器（<code>.class</code>）可以迅速定位到目标元素。</li></ul></details><details class="details custom-block"><summary><strong>避免冗余样式</strong></summary><p>删除未使用的 CSS 规则，确保所有样式都有实际用处。</p><ul><li>通过工具（如 PurifyCSS、UnCSS）可以自动检测和删除未使用的 CSS 规则。</li><li>保持 CSS 文件干净整洁，对维护也非常友好。</li></ul></details><details class="details custom-block"><summary><strong>合理使用 CSS Sprite</strong></summary><p>将多个小图标合并成一张图，通过 <code>background-position</code> 实现图标显示，减少 HTTP 请求。</p><ul><li>将多个图标合并成一张大图，并通过背景定位显示特定部分，可以显著减少 HTTP 请求数，提高加载速度。</li><li>工具 SpriteSmith 可以帮助生成 Sprite 图。</li></ul></details><details class="details custom-block"><summary><strong>使用 CSS 动画的调优</strong></summary><p>避免复杂的动画，尽量使用 <code>transform</code> 和 <code>opacity</code>，它们对性能影响较小。</p><ul><li>对比普通的属性，<code>transform</code> 和 <code>opacity</code> 不会触发布局和绘制，只会触发合成，这使得它们在渲染过程中更高效。</li><li>例如，可以用 <code>transform: translateX(100px)</code> 代替 <code>left: 100px</code>。</li></ul></details><details class="details custom-block"><summary><strong>CSS 放置位置</strong></summary><p>在 HTML 中，CSS 文件应放在 <code>head</code> 标签内，确保页面加载时能尽快应用样式。</p><ul><li>如果将 CSS 文件放在 <code>body</code> 底部，在样式加载完成之前页面内容可能没有样式，会影响用户体验。</li><li>所以一般情况下会将 CSS 文件放在 <code>head</code> 中，以保证样式尽快加载和解析。</li></ul></details><details class="details custom-block"><summary><strong>使用内联样式进行关键渲染路径优化</strong></summary><p>对于首屏重要的样式，可以使用内联 CSS，减少首次渲染时间。</p><ul><li>对于初次加载页面的关键样式，可以直接写在 HTML 中，这样浏览器就不必等待外部 CSS 文件加载完成，能够更快呈现出内容。</li><li>例如，可以在 <code>head</code> 中通过 <code>&lt;style&gt;</code> 标签添加。</li></ul></details><h3 id="如何检测-css-动画的-fps-值" tabindex="-1">如何检测 CSS 动画的 FPS 值 ? <a class="header-anchor" href="#如何检测-css-动画的-fps-值" aria-label="Permalink to &quot;如何检测 CSS 动画的 FPS 值 ?&quot;">​</a></h3><p>检测 CSS 动画的 FPS（帧率）值，即每秒呈现的帧数，可以通过 JavaScript 与 requestAnimationFrame 方法配合相应的时间计算来实现。基本思路是每帧动画时记录当前时间，并通过时间差计算帧率。</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lastTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> performance.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> frameCount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> measureFPS</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> performance.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">now</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    frameCount</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (currentTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> lastTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 每秒统计一次</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fps </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> frameCount;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`FPS: \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fps</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        frameCount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        lastTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentTime;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    requestAnimationFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(measureFPS);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">requestAnimationFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(measureFPS);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><details class="details custom-block"><summary>补充</summary><p>这个问题涉及一些关于前端动画性能优化的知识点，我可以进一步讲解几个重要的方面：</p><p><strong>1）requestAnimationFrame 方法：</strong></p><p>这是一个用于告知浏览器你希望执行动画并请求浏览器在下一次重绘之前调用指定的回调函数的方法。</p><p>与传统的 <code>setInterval</code> 不同，<code>requestAnimationFrame</code> 能够更智能地优化动画效果，使其更加流畅。</p><p>浏览器会根据自身的刷新频率（通常是60Hz）来调用这个函数，让动画帧率更加稳定。</p><p><strong>2）性能检测工具：</strong></p><p>除手写 FPS 检测代码外，许多浏览器自带开发者工具也可以帮助检测动画性能。</p><p>例如，Chrome 开发者工具的 &quot;Performance&quot; 标签，Safari 的 &quot;Timelines&quot; 标签，这些工具可以记录并分析动画执行情况，显示 CPU 使用率和 FPS。</p><p><strong>3）资源优化技巧：</strong></p><ul><li>CSS3硬件加速：通过使用 <code>transform</code>、<code>opacity</code> 等属性代替 <code>top</code>、<code>left</code> 可以显著提升动画性能，因为前者可以利用 GPU 进行硬件加速。</li><li>减少重排和重绘：保证动画过程中不会频繁触发布局（重排）和绘制（重绘），这可以通过精简 DOM 结构和避免昂贵的样式计算来实现。</li><li>动画特效库：使用专门为高性能设计的动画库如 GSAP、Three.js 也能进一步优化动画的流畅度和性能，很多库都内建了高效的动画管理机制。</li></ul><p><strong>4）现代 Web API：</strong></p><ul><li>Intersection Observer：对于涉及视窗内外切换的动画，可以通过 Intersection Observer 来监测 DOM 元素是否在视窗内，来基于元素可见性动态控制动画的开启与关闭。</li><li>Web Animations API：提供了更强大、细粒度的动画控制，对于创建复杂的动画效果，可以更方便地使用并优化动画性能。</li></ul></details>`,21)]))}const E=i(e,[["render",t]]);export{c as __pageData,E as default};
